function source = define_source_frequency(Transducer, Transmit, Medium, ...
    Grid, frequencies, useGPU)
%DEFINE_SOURCE_FREQUENCY converts GUI output parameter structs into a
%source struct that can be used for the rayleigh integral approach in the
%frequency domain.
%
% INPUT ARGUMENTS:
% - Transducer is the Transducer struct after calling 
%   get_transducer_integration_points.
% - Transmit is the Transmit structure generated by MainGUI.
% - Medium is the Medium structure generated by MainGUI.
% - Grid is generated by define_grid
% - frequencies at which the Rayleigh integral should be evaluated
% 
% RETURNS source, a struct with fields:
% - points:       source points [m],                      Npoints-by-3
% - velocities*:  normal velocities [m/s],                Npoints-Nfreq
% - pressures*:   normal velocities [m/s],                Npoints-Nfreq
% - normal:       normal vector at each source point,     Npoints-by-3
% - weights:      integration element surface area [m^2], Npoints-by-1
% - frequencies:  frequency vector [Hz],                  1-by-Nfreq
% - type:         'velocity' or 'pressure'
%
% * either velocities or pressures, depending on the value of
% Transducer.SourceType
% Transducer.SourceType = 'dipole' returns 'pressure' type
% Transducer.SourceType = 'monopole' returns 'velocity' type
% Transducer.SourceType unspecified returns 'velocity type
%
% If frequencies is empty, the first half of the frequency spectrum of
% Transmit.PressureSignal is used.
%
% If Transducer.ContinuousWave = true, the value of
% Transmit.AcousticPressure is applied to all frequency components.
%
% This file is part of the transducer-characterization project, licensed
% under the GNU Lesser General Public License v3.0 (LGPL-3.0).
% See the LICENSE file for further details.
% Copyright (C) 2025 Nathan Blanken

source.points = reshape(Transducer.integration_points,[],3);

rho = Medium.Density;
c0  = Medium.SpeedOfSound;

% Frequency vector:
N = length(Transmit.PressureSignal);
f = (0:(N-1))/N*Transmit.SamplingRate;

if isempty(frequencies)
    % Real signals have a conjugate symmetric Fourier transform. Only keep
    % the first M frequency components, where M is the frequency component
    % at or just before the folding frequency Fs/2. The other frequency
    % components can be recovered using the symmetry property.
    M = ceil((N+1)/2);
    frequencies = f(1:M);
    interpolation = false;
else
    interpolation = true;
end

source.frequencies = frequencies;

% Frequency vector:
omega = 2*pi*transpose(frequencies);

% Apply electronic delays:
delays = Transducer.integration_transmit_delays;
delays = delays + transpose(Transmit.Delays);

% Apply electronic apodization:
apod   = Transducer.integration_transmit_apodization;
apod   = apod.*transpose(Transmit.Apodization);

delays = reshape(delays(:),1,[]);
apod   = reshape(apod(:)  ,1,[]);

if isfield(Transmit,'ContinuousWave') && Transmit.ContinuousWave == true
    p = Transmit.AcousticPressure;
else
    % Frequency domain pressure data
    p = Transmit.PressureSignal;
    p = conj(fft(p));
    p = transpose(p);

    % Values at query frequencies
    if interpolation
        p = sinc_interpolation_periodic(f,p,frequencies);
    else
        p = p(1:M);
    end
end

if useGPU
    % Put variables on GPU:
    delays = gpuArray(delays);
    apod   = gpuArray(apod);
    omega  = gpuArray(omega);
end

if isfield(Transducer,'SourceType') && ...
        strcmp(Transducer.SourceType,'dipole')
    % Velocity amplitude for each source point and frequency:
    source.pressures = p*apod.*exp(1i*omega.*delays);
    source.pressures = gather(source.pressures);
    source.pressures = transpose(source.pressures);
    source.type      = 'pressure';
else
    % Velocity amplitude for each source point and frequency:
    source.velocities = p*apod.*exp(1i*omega.*delays)/(rho*c0);
    source.velocities = gather(source.velocities);
    source.velocities = transpose(source.velocities);
    source.type       = 'velocity';
end

% Normal vector at each source location pointing into the medium:
source.normal = zeros(size(source.points));
if isfield(Transducer,'Axis')
    source.normal(:,Transducer.Axis) = 1;
else
    source.normal(:,1) = 1;
end

% Area of an integration element. The integration weights should always be
% multiplied by dy*dz (not dx*dy or dz*dx), regardless of the orientation.
% See: https://github.com/PROTEUS-SIM/PROTEUS/blob/
% main/acoustic-module/get_transducer_integration_points.m
% Also see Eqs. 31 and 32 in the arXiv preprint.
dA = Grid.dy*Grid.dz*Transducer.integration_weights;
source.weights = dA*ones(size(source.points,1),1);

end
